1. FOR FINDING SINGLE SOURCE SHORTEST PATH FROM ANY NODE IN A TREE, WE NEED TO RUN DFS WITH ANOTHER PARAMETER SIZE AND INCREASE SIZE BY 1 AT EACH DFS CALL, AND MAKE A NEW MAP TO SAVE THE DISTANCES OF THE NODES FROM THE MAIN CHOSEN NODE. 
	void dfs(ll a, ll size)
	{
		visited[a]=1;
		for(auto itr = adj[a].begin(); itr!=adj[a].end(); itr++)
		{
			if(visited[*itr]==0)
			{
				distance[a]=size;
				dfs(*itr,size+1);
			}
		}
	}

2. TO FIND WHETHER A GRAPH IS A TREE OR NOT, WE NEED TO CHECK TWO CONDITIONS
	A = IT SHOULD NOT HAVE MORE THAN ONE CONNECTED COMPONENTS, AS THE TREE CAN NEVER BE DISCONNECTED LIKE GRAPHS.
	B = TREE DO NOT HAVE ANY CYCLE, SO WE WILL CHECK IF, NUMBER OF EDGE + 1 = NUMBER OF NODES, THIS WILL PROVE THAT 	A GRAPH DOES NOT HAVE A CYCLE, AND IT IS A TREE. 

3. TO FIND DIAMETER OF A TREE, WE HAVE 4 METHODS, TWO OF THEM WERE SEEN IN TREES USING HEIGHT OF THE LEFT AND RIGHT 
	SUBTREES + 1, NOW WE HAVE TWO MORE METHODS.
	A = ITERATE THROUGH EVERY NODE AND FIND THE FARTHEST DISTANCE FROM IT WITH THE HELP OF SINGLE SOURCE SHORTEST 
		PATH IN DFS MAKING THAT NODE AS MAIN NODE, AND WE WILL UPDATE MAXIMUM EVERYTIME. O(N^2)
	B = TAKE ANY NODE AS A ROOT, FIND A FARTHEST NODE FROM IT(CAN BE MULTIPLE), THE FARTHEST NODE FOUND IS ONE OF 
		THE END POINTS OF DIAMETER, SO TAKE THAT AS A ROOT AND FIND THE FARTHEST NODE FROM IT AND MAKE THEIR DISTANCE AS THE DIAMETER OF THE TREE.